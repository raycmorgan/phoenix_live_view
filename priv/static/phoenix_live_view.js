(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["phoenix_live_view"] = factory();
	else
		root["phoenix_live_view"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/phoenix_live_view.js-exposed");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/phoenix_live_view.js-exposed":
/*!*****************************************!*\
  !*** ./js/phoenix_live_view.js-exposed ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {if(!global[\"Phoenix\"]) global[\"Phoenix\"] = {};\nmodule.exports = global[\"Phoenix\"][\"LiveView\"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib!./phoenix_live_view.js */ \"./node_modules/babel-loader/lib/index.js!./js/phoenix_live_view.js\");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://phoenix_live_view/./js/phoenix_live_view.js-exposed?");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./js/phoenix_live_view.js":
/*!*****************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./js/phoenix_live_view.js ***!
  \*****************************************************************/
/*! exports provided: debug, Rendered, LiveSocket, Browser, View, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"debug\", function() { return debug; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rendered\", function() { return Rendered; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiveSocket\", function() { return LiveSocket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Browser\", function() { return Browser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"View\", function() { return View; });\n/* harmony import */ var morphdom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! morphdom */ \"./node_modules/morphdom/dist/morphdom-esm.js\");\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"phoenix\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n================================================================================\nPhoenix LiveView JavaScript Client\n================================================================================\n\n## Usage\n\nInstantiate a single LiveSocket instance to enable LiveView\nclient/server interaction, for example:\n\n    import LiveSocket from \"live_view\"\n\n    let liveSocket = new LiveSocket(\"/live\")\n    liveSocket.connect()\n\nA LiveSocket can also be created from an existing socket:\n\n    import { Socket } from \"phoenix\"\n    import LiveSocket from \"live_view\"\n\n    let socket = new Socket(\"/live\")\n    let liveSocket = new LiveSocket(socket)\n    liveSocket.connect()\n\nAll options are passed directly to the `Phoenix.Socket` constructor,\nexcept for the following LiveView specific options:\n\n  * `bindingPrefix` - the prefix to use for phoenix bindings. Defaults `\"phx-\"`\n\n## Events\n\n### Click Events\n\nWhen pushed, the value sent to the server will be chosen with the\nfollowing priority:\n\n  - An optional `\"phx-value\"` binding on the clicked element\n  - The clicked element's `value` property\n  - An empty string\n\n### Key Events\n\nThe onkeydown and onkeyup events are supported via\nthe `phx-keydown`, and `phx-keyup` bindings. By\ndefault, the bound element will be the event listener, but an\noptional `phx-target` may be provided which may be `\"window\"`.\n\nWhen pushed, the value sent to the server will be the event's `key`.\n\n### Focus and Blur Events\n\nFocus and blur events may be bound to DOM elements that emit\nsuch events, using the `phx-blur`, and `phx-focus` bindings, for example:\n\n    <input name=\"email\" phx-focus=\"myfocus\" phx-blur=\"myblur\"/>\n\nTo detect when the page itself has receive focus or blur,\n`phx-target` may be specified as `\"window\"`. Like other\nbindings, a `phx-value` can be provided on the bound element,\notherwise the input's value will be used. For example:\n\n    <div class=\"container\"\n        phx-focus=\"page-active\"\n        phx-blur=\"page-inactive\"\n        phx-target=\"window\">\n    ...\n    </div>\n\n## Forms and input handling\n\nThe JavaScript client is always the source of truth for current\ninput values. For any given input with focus, LiveView will never\noverwrite the input's current value, even if it deviates from\nthe server's rendered updates. This works well for updates where\nmajor side effects are not expected, such as form validation errors,\nor additive UX around the user's input values as they fill out a form.\nFor these use cases, the `phx-change` input does not concern itself\nwith disabling input editing while an event to the server is inflight.\n\nThe `phx-submit` event is used for form submissions where major side-effects\ntypically happen, such as rendering new containers, calling an external\nservice, or redirecting to a new page. For these use-cases, the form inputs\nare set to `readonly` on submit, and any submit button is disabled until\nthe client gets an acknowledgment that the server has processed the\n`phx-submit` event. Following an acknowledgment, any updates are patched\nto the DOM as normal, and the last input with focus is restored if the\nuser has not otherwise focused on a new input during submission.\n\nTo handle latent form submissions, any HTML tag can be annotated with\n`phx-disable-with`, which swaps the element's `innerText` with the provided\nvalue during form submission. For example, the following code would change\nthe \"Save\" button to \"Saving...\", and restore it to \"Save\" on acknowledgment:\n\n    <button type=\"submit\" phx-disable-with=\"Saving...\">Save</button>\n\n\n## Loading state and Errors\n\nBy default, the following classes are applied to the live view's parent\ncontainer:\n\n  - `\"phx-connected\"` - applied when the view has connected to the server\n  - `\"phx-disconnected\"` - applied when the view is not connected to the server\n  - `\"phx-error\"` - applied when an error occurs on the server. Note, this\n    class will be applied in conjunction with `\"phx-disconnected\"` connection\n    to the server is lost.\n\nWhen a form bound with `phx-submit` is submitted, the `phx-loading` class\nis applied to the form, which is removed on update.\n\nIn addition to applied classes, an empty `\"phx-loader\"` exists adjacent\nto every LiveView, and its display status is toggled automatically based on\nconnection and error class changes. This behavior may be disabled by overriding\n`.phx-loader` in your css to `display: none !important`.\n*/\n\n\nvar PHX_VIEW = \"data-phx-view\";\nvar PHX_CONNECTED_CLASS = \"phx-connected\";\nvar PHX_LOADING_CLASS = \"phx-loading\";\nvar PHX_DISCONNECTED_CLASS = \"phx-disconnected\";\nvar PHX_ERROR_CLASS = \"phx-error\";\nvar PHX_PARENT_ID = \"data-phx-parent-id\";\nvar PHX_VIEW_SELECTOR = \"[\".concat(PHX_VIEW, \"]\");\nvar PHX_ERROR_FOR = \"data-phx-error-for\";\nvar PHX_HAS_FOCUSED = \"data-phx-has-focused\";\nvar PHX_BOUND = \"data-phx-bound\";\nvar FOCUSABLE_INPUTS = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\"];\nvar PHX_HAS_SUBMITTED = \"data-phx-has-submitted\";\nvar PHX_SESSION = \"data-phx-session\";\nvar PHX_STATIC = \"data-phx-static\";\nvar PHX_READONLY = \"data-phx-readonly\";\nvar PHX_DISABLED = \"data-phx-disabled\";\nvar PHX_DISABLE_WITH = \"disable-with\";\nvar LOADER_TIMEOUT = 100;\nvar LOADER_ZOOM = 2;\nvar BINDING_PREFIX = \"phx-\";\nvar PUSH_TIMEOUT = 20000;\nvar debug = function debug(view, kind, msg, obj) {\n  console.log(\"\".concat(view.id, \" \").concat(kind, \": \").concat(msg, \" - \"), obj);\n};\n\nvar closestPhxBinding = function closestPhxBinding(el, binding) {\n  do {\n    if (el.matches(\"[\".concat(binding, \"]\"))) {\n      return el;\n    }\n\n    el = el.parentElement || el.parentNode;\n  } while (el !== null && el.nodeType === 1 && !el.matches(PHX_VIEW_SELECTOR));\n\n  return null;\n};\n\nvar isObject = function isObject(obj) {\n  return _typeof(obj) === \"object\" && !(obj instanceof Array);\n};\n\nvar isEmpty = function isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nvar maybe = function maybe(el, key) {\n  if (el) {\n    return el[key];\n  } else {\n    return null;\n  }\n};\n\nvar serializeForm = function serializeForm(form) {\n  return new URLSearchParams(new FormData(form)).toString();\n};\n\nvar recursiveMerge = function recursiveMerge(target, source) {\n  for (var key in source) {\n    var val = source[key];\n\n    if (isObject(val) && target[key]) {\n      recursiveMerge(target[key], val);\n    } else {\n      target[key] = val;\n    }\n  }\n};\n\nvar Session = {\n  get: function get(el) {\n    return el.getAttribute(PHX_SESSION);\n  },\n  isEqual: function isEqual(el1, el2) {\n    return this.get(el1) === this.get(el2);\n  }\n};\nvar Rendered = {\n  mergeDiff: function mergeDiff(source, diff) {\n    if (this.isNewFingerprint(diff)) {\n      return diff;\n    } else {\n      recursiveMerge(source, diff);\n      return source;\n    }\n  },\n  isNewFingerprint: function isNewFingerprint() {\n    var diff = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return !!diff.static;\n  },\n  toString: function toString(rendered) {\n    var output = {\n      buffer: \"\"\n    };\n    this.toOutputBuffer(rendered, output);\n    return output.buffer;\n  },\n  toOutputBuffer: function toOutputBuffer(rendered, output) {\n    if (rendered.dynamics) {\n      return this.comprehensionToBuffer(rendered, output);\n    }\n\n    var statics = rendered.static;\n    output.buffer += statics[0];\n\n    for (var i = 1; i < statics.length; i++) {\n      this.dynamicToBuffer(rendered[i - 1], output);\n      output.buffer += statics[i];\n    }\n  },\n  comprehensionToBuffer: function comprehensionToBuffer(rendered, output) {\n    var dynamics = rendered.dynamics,\n        statics = rendered.static;\n\n    for (var d = 0; d < dynamics.length; d++) {\n      var dynamic = dynamics[d];\n      output.buffer += statics[0];\n\n      for (var i = 1; i < statics.length; i++) {\n        this.dynamicToBuffer(dynamic[i - 1], output);\n        output.buffer += statics[i];\n      }\n    }\n  },\n  dynamicToBuffer: function dynamicToBuffer(rendered, output) {\n    if (isObject(rendered)) {\n      this.toOutputBuffer(rendered, output);\n    } else {\n      output.buffer += rendered;\n    }\n  }\n}; // todo document LiveSocket specific options like viewLogger\n\nvar LiveSocket =\n/*#__PURE__*/\nfunction () {\n  function LiveSocket(url) {\n    var _this = this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, LiveSocket);\n\n    this.unloaded = false;\n    this.socket = new !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"phoenix\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(url, opts);\n    this.socket.onOpen(function () {\n      if (_this.isUnloaded()) {\n        _this.destroyAllViews();\n\n        _this.joinRootViews();\n      }\n\n      _this.unloaded = false;\n    });\n    window.addEventListener(\"beforeunload\", function (e) {\n      _this.unloaded = true;\n    });\n    this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;\n    this.opts = opts;\n    this.views = {};\n    this.viewLogger = opts.viewLogger;\n    this.activeElement = null;\n    this.prevActive = null;\n    this.prevInput = null;\n    this.prevValue = null;\n    this.silenced = false;\n    this.bindTopLevelEvents();\n  }\n\n  _createClass(LiveSocket, [{\n    key: \"isUnloaded\",\n    value: function isUnloaded() {\n      return this.unloaded;\n    }\n  }, {\n    key: \"getSocket\",\n    value: function getSocket() {\n      return this.socket;\n    }\n  }, {\n    key: \"log\",\n    value: function log(view, kind, msgCallback) {\n      if (this.viewLogger) {\n        var _msgCallback = msgCallback(),\n            _msgCallback2 = _slicedToArray(_msgCallback, 2),\n            msg = _msgCallback2[0],\n            obj = _msgCallback2[1];\n\n        this.viewLogger(view, kind, msg, obj);\n      }\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      if ([\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0) {\n        this.joinRootViews();\n      } else {\n        document.addEventListener(\"DOMContentLoaded\", function () {\n          _this2.joinRootViews();\n        });\n      }\n\n      return this.socket.connect();\n    }\n  }, {\n    key: \"getBindingPrefix\",\n    value: function getBindingPrefix() {\n      return this.bindingPrefix;\n    }\n  }, {\n    key: \"binding\",\n    value: function binding(kind) {\n      return \"\".concat(this.getBindingPrefix()).concat(kind);\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.socket.disconnect();\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic, params) {\n      return this.socket.channel(topic, params || {});\n    }\n  }, {\n    key: \"joinRootViews\",\n    value: function joinRootViews() {\n      var _this3 = this;\n\n      document.querySelectorAll(\"\".concat(PHX_VIEW_SELECTOR, \":not([\").concat(PHX_PARENT_ID, \"])\")).forEach(function (rootEl) {\n        _this3.joinView(rootEl);\n      });\n    }\n  }, {\n    key: \"joinView\",\n    value: function joinView(el, parentView) {\n      if (this.getViewById(el.id)) {\n        return;\n      }\n\n      var view = new View(el, this, parentView);\n      this.views[view.id] = view;\n      view.join();\n    }\n  }, {\n    key: \"owner\",\n    value: function owner(childEl, callback) {\n      var view = this.getViewById(maybe(childEl.closest(PHX_VIEW_SELECTOR), \"id\"));\n\n      if (view) {\n        callback(view);\n      }\n    }\n  }, {\n    key: \"getViewById\",\n    value: function getViewById(id) {\n      return this.views[id];\n    }\n  }, {\n    key: \"onViewError\",\n    value: function onViewError(view) {\n      this.dropActiveElement(view);\n    }\n  }, {\n    key: \"destroyAllViews\",\n    value: function destroyAllViews() {\n      for (var id in this.views) {\n        this.destroyViewById(id);\n      }\n    }\n  }, {\n    key: \"destroyViewById\",\n    value: function destroyViewById(id) {\n      var view = this.views[id];\n\n      if (view) {\n        delete this.views[view.id];\n        view.destroy();\n      }\n    }\n  }, {\n    key: \"setActiveElement\",\n    value: function setActiveElement(target) {\n      var _this4 = this;\n\n      if (this.activeElement === target) {\n        return;\n      }\n\n      this.activeElement = target;\n\n      var cancel = function cancel() {\n        if (target === _this4.activeElement) {\n          _this4.activeElement = null;\n        }\n\n        target.removeEventListener(\"mouseup\", _this4);\n        target.removeEventListener(\"touchend\", _this4);\n      };\n\n      target.addEventListener(\"mouseup\", cancel);\n      target.addEventListener(\"touchend\", cancel);\n    }\n  }, {\n    key: \"getActiveElement\",\n    value: function getActiveElement() {\n      if (document.activeElement === document.body) {\n        return this.activeElement || document.activeElement;\n      } else {\n        return document.activeElement;\n      }\n    }\n  }, {\n    key: \"dropActiveElement\",\n    value: function dropActiveElement(view) {\n      if (this.prevActive && view.ownsElement(this.prevActive)) {\n        this.prevActive = null;\n      }\n    }\n  }, {\n    key: \"restorePreviouslyActiveFocus\",\n    value: function restorePreviouslyActiveFocus() {\n      if (this.prevActive && this.prevActive !== document.body) {\n        this.prevActive.focus();\n      }\n    }\n  }, {\n    key: \"blurActiveElement\",\n    value: function blurActiveElement() {\n      this.prevActive = this.getActiveElement();\n\n      if (this.prevActive !== document.body) {\n        this.prevActive.blur();\n      }\n    }\n  }, {\n    key: \"bindTopLevelEvents\",\n    value: function bindTopLevelEvents() {\n      this.bindClicks();\n      this.bindForms();\n      this.bindTargetable({\n        keyup: \"keyup\",\n        keydown: \"keydown\"\n      }, function (e, type, view, target, phxEvent, phxTarget) {\n        view.pushKey(target, type, e, phxEvent);\n      });\n      this.bindTargetable({\n        blur: \"focusout\",\n        focus: \"focusin\"\n      }, function (e, type, view, targetEl, phxEvent, phxTarget) {\n        if (!phxTarget) {\n          view.pushEvent(type, targetEl, phxEvent);\n        }\n      });\n      this.bindTargetable({\n        blur: \"blur\",\n        focus: \"focus\"\n      }, function (e, type, view, targetEl, phxEvent, phxTarget) {\n        // blur and focus are triggered on document and window. Discard one to avoid dups\n        if (phxTarget && !phxTarget !== \"window\") {\n          view.pushEvent(type, targetEl, phxEvent);\n        }\n      });\n    } // private\n\n  }, {\n    key: \"bindTargetable\",\n    value: function bindTargetable(events, callback) {\n      var _this5 = this;\n\n      var _loop = function _loop(event) {\n        var browserEventName = events[event];\n\n        _this5.on(browserEventName, function (e) {\n          var binding = _this5.binding(event);\n\n          var bindTarget = _this5.binding(\"target\");\n\n          var targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);\n\n          if (targetPhxEvent && !e.target.getAttribute(bindTarget)) {\n            _this5.owner(e.target, function (view) {\n              return callback(e, event, view, e.target, targetPhxEvent, null);\n            });\n          } else {\n            document.querySelectorAll(\"[\".concat(binding, \"][\").concat(bindTarget, \"=window]\")).forEach(function (el) {\n              var phxEvent = el.getAttribute(binding);\n\n              _this5.owner(el, function (view) {\n                return callback(e, event, view, el, phxEvent, \"window\");\n              });\n            });\n          }\n        });\n      };\n\n      for (var event in events) {\n        _loop(event);\n      }\n    }\n  }, {\n    key: \"bindClicks\",\n    value: function bindClicks() {\n      var _this6 = this;\n\n      window.addEventListener(\"click\", function (e) {\n        var click = _this6.binding(\"click\");\n\n        var target = closestPhxBinding(e.target, click);\n        var phxEvent = target && target.getAttribute(click);\n\n        if (!phxEvent) {\n          return;\n        }\n\n        e.preventDefault();\n\n        _this6.owner(target, function (view) {\n          return view.pushEvent(\"click\", target, phxEvent);\n        });\n      }, false);\n    }\n  }, {\n    key: \"bindForms\",\n    value: function bindForms() {\n      var _this7 = this;\n\n      this.on(\"submit\", function (e) {\n        var phxEvent = e.target.getAttribute(_this7.binding(\"submit\"));\n\n        if (!phxEvent) {\n          return;\n        }\n\n        e.preventDefault();\n        e.target.disabled = true;\n\n        _this7.owner(e.target, function (view) {\n          return view.submitForm(e.target, phxEvent);\n        });\n      }, false);\n      var _arr2 = [\"change\", \"input\"];\n\n      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n        var type = _arr2[_i2];\n        this.on(type, function (e) {\n          var input = e.target;\n          var key = input.type === \"checkbox\" ? \"checked\" : \"value\";\n\n          if (_this7.prevInput === input && _this7.prevValue === input[key]) {\n            return;\n          }\n\n          _this7.prevInput = input;\n          _this7.prevValue = input[key];\n          var phxEvent = input.form && input.form.getAttribute(_this7.binding(\"change\"));\n\n          if (!phxEvent) {\n            return;\n          }\n\n          _this7.owner(input, function (view) {\n            if (DOM.isTextualInput(input)) {\n              input.setAttribute(PHX_HAS_FOCUSED, true);\n            } else {\n              _this7.setActiveElement(input);\n            }\n\n            view.pushInput(input, phxEvent);\n          });\n        }, false);\n      }\n    }\n  }, {\n    key: \"silenceEvents\",\n    value: function silenceEvents(callback) {\n      this.silenced = true;\n      callback();\n      this.silenced = false;\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      var _this8 = this;\n\n      window.addEventListener(event, function (e) {\n        if (!_this8.silenced) {\n          callback(e);\n        }\n      });\n    }\n  }]);\n\n  return LiveSocket;\n}();\nvar Browser = {\n  setCookie: function setCookie(name, value) {\n    document.cookie = \"\".concat(name, \"=\").concat(value);\n  },\n  getCookie: function getCookie(name) {\n    return document.cookie.replace(new RegExp(\"(?:(?:^|.*;s*)\".concat(name, \"s*=s*([^;]*).*$)|^.*$\")), \"$1\");\n  },\n  redirect: function redirect(toURL, flash) {\n    if (flash) {\n      Browser.setCookie(\"__phoenix_flash__\", flash + \"; max-age=60000; path=/\");\n    }\n\n    window.location = toURL;\n  }\n};\nvar DOM = {\n  disableForm: function disableForm(form, prefix) {\n    var disableWith = \"\".concat(prefix).concat(PHX_DISABLE_WITH);\n    form.classList.add(PHX_LOADING_CLASS);\n    form.querySelectorAll(\"[\".concat(disableWith, \"]\")).forEach(function (el) {\n      var value = el.getAttribute(disableWith);\n      el.setAttribute(\"\".concat(disableWith, \"-restore\"), el.innerText);\n      el.innerText = value;\n    });\n    form.querySelectorAll(\"button\").forEach(function (button) {\n      button.setAttribute(PHX_DISABLED, button.disabled);\n      button.disabled = true;\n    });\n    form.querySelectorAll(\"input\").forEach(function (input) {\n      input.setAttribute(PHX_READONLY, input.readOnly);\n      input.readOnly = true;\n    });\n  },\n  restoreDisabledForm: function restoreDisabledForm(form, prefix) {\n    var disableWith = \"\".concat(prefix).concat(PHX_DISABLE_WITH);\n    form.classList.remove(PHX_LOADING_CLASS);\n    form.querySelectorAll(\"[\".concat(disableWith, \"]\")).forEach(function (el) {\n      var value = el.getAttribute(\"\".concat(disableWith, \"-restore\"));\n\n      if (value) {\n        el.innerText = value;\n        el.removeAttribute(\"\".concat(disableWith, \"-restore\"));\n      }\n    });\n    form.querySelectorAll(\"button\").forEach(function (button) {\n      var prev = button.getAttribute(PHX_DISABLED);\n\n      if (prev) {\n        button.disabled = prev === \"true\";\n        button.removeAttribute(PHX_DISABLED);\n      }\n    });\n    form.querySelectorAll(\"input\").forEach(function (input) {\n      var prev = input.getAttribute(PHX_READONLY);\n\n      if (prev) {\n        input.readOnly = prev === \"true\";\n        input.removeAttribute(PHX_READONLY);\n      }\n    });\n  },\n  discardError: function discardError(el) {\n    var field = el.getAttribute && el.getAttribute(PHX_ERROR_FOR);\n\n    if (!field) {\n      return;\n    }\n\n    var input = document.getElementById(field);\n\n    if (field && !(input.getAttribute(PHX_HAS_FOCUSED) || input.form.getAttribute(PHX_HAS_SUBMITTED))) {\n      el.style.display = \"none\";\n    }\n  },\n  isPhxChild: function isPhxChild(node) {\n    return node.getAttribute && node.getAttribute(PHX_PARENT_ID);\n  },\n  patch: function patch(view, container, id, html) {\n    var focused = view.liveSocket.getActiveElement();\n    var selectionStart = null;\n    var selectionEnd = null;\n\n    if (DOM.isTextualInput(focused)) {\n      selectionStart = focused.selectionStart;\n      selectionEnd = focused.selectionEnd;\n    }\n\n    Object(morphdom__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(container, \"<div>\".concat(html, \"</div>\"), {\n      childrenOnly: true,\n      onBeforeNodeAdded: function onBeforeNodeAdded(el) {\n        //input handling\n        DOM.discardError(el);\n        return el;\n      },\n      onNodeAdded: function onNodeAdded(el) {\n        // nested view handling\n        if (DOM.isPhxChild(el) && view.ownsElement(el)) {\n          view.onNewChildAdded();\n          return true;\n        }\n      },\n      onBeforeNodeDiscarded: function onBeforeNodeDiscarded(el) {\n        // nested view handling\n        if (DOM.isPhxChild(el)) {\n          view.liveSocket.destroyViewById(el.id);\n          return true;\n        }\n      },\n      onBeforeElUpdated: function onBeforeElUpdated(fromEl, toEl) {\n        // nested view handling\n        if (DOM.isPhxChild(toEl)) {\n          var prevStatic = fromEl.getAttribute(PHX_STATIC);\n\n          if (!Session.isEqual(toEl, fromEl)) {\n            view.liveSocket.destroyViewById(fromEl.id);\n            view.onNewChildAdded();\n          }\n\n          DOM.mergeAttrs(fromEl, toEl);\n          fromEl.setAttribute(PHX_STATIC, prevStatic);\n          return false;\n        } // input handling\n\n\n        if (fromEl.getAttribute && fromEl.getAttribute(PHX_HAS_SUBMITTED)) {\n          toEl.setAttribute(PHX_HAS_SUBMITTED, true);\n        }\n\n        if (fromEl.getAttribute && fromEl.getAttribute(PHX_HAS_FOCUSED)) {\n          toEl.setAttribute(PHX_HAS_FOCUSED, true);\n        }\n\n        DOM.discardError(toEl);\n\n        if (DOM.isTextualInput(fromEl) && fromEl === focused) {\n          DOM.mergeInputs(fromEl, toEl);\n          return false;\n        } else {\n          return true;\n        }\n      }\n    });\n    view.liveSocket.silenceEvents(function () {\n      DOM.restoreFocus(focused, selectionStart, selectionEnd);\n    });\n    document.dispatchEvent(new Event(\"phx:update\"));\n  },\n  mergeAttrs: function mergeAttrs(target, source) {\n    source.getAttributeNames().forEach(function (name) {\n      var value = source.getAttribute(name);\n      target.setAttribute(name, value);\n    });\n  },\n  mergeInputs: function mergeInputs(target, source) {\n    DOM.mergeAttrs(target, source);\n    target.readOnly = source.readOnly;\n  },\n  restoreFocus: function restoreFocus(focused, selectionStart, selectionEnd) {\n    if (!DOM.isTextualInput(focused)) {\n      return;\n    }\n\n    if (focused.value === \"\" || focused.readOnly) {\n      focused.blur();\n    }\n\n    focused.focus();\n\n    if (focused.setSelectionRange && focused.type === \"text\" || focused.type === \"textarea\") {\n      focused.setSelectionRange(selectionStart, selectionEnd);\n    }\n  },\n  isTextualInput: function isTextualInput(el) {\n    return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;\n  }\n};\nvar View =\n/*#__PURE__*/\nfunction () {\n  function View(el, liveSocket, parentView) {\n    var _this9 = this;\n\n    _classCallCheck(this, View);\n\n    this.liveSocket = liveSocket;\n    this.parent = parentView;\n    this.newChildrenAdded = false;\n    this.gracefullyClosed = false;\n    this.el = el;\n    this.loader = this.el.nextElementSibling;\n    this.id = this.el.id;\n    this.view = this.el.getAttribute(PHX_VIEW);\n    this.channel = this.liveSocket.channel(\"lv:\".concat(this.id), function () {\n      return {\n        session: _this9.getSession(),\n        static: _this9.getStatic()\n      };\n    });\n    this.loaderTimer = setTimeout(function () {\n      return _this9.showLoader();\n    }, LOADER_TIMEOUT);\n    this.bindChannel();\n  }\n\n  _createClass(View, [{\n    key: \"getSession\",\n    value: function getSession() {\n      return Session.get(this.el);\n    }\n  }, {\n    key: \"getStatic\",\n    value: function getStatic() {\n      var val = this.el.getAttribute(PHX_STATIC);\n      return val === \"\" ? null : val;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\n      if (this.hasGracefullyClosed()) {\n        this.log(\"destroyed\", function () {\n          return [\"the server view has gracefully closed\"];\n        });\n        callback();\n      } else {\n        this.log(\"destroyed\", function () {\n          return [\"the child has been removed from the parent\"];\n        });\n        this.channel.leave().receive(\"ok\", callback).receive(\"error\", callback).receive(\"timeout\", callback);\n      }\n    }\n  }, {\n    key: \"hideLoader\",\n    value: function hideLoader() {\n      clearTimeout(this.loaderTimer);\n      this.loader.style.display = \"none\";\n    }\n  }, {\n    key: \"showLoader\",\n    value: function showLoader() {\n      clearTimeout(this.loaderTimer);\n      this.el.classList = PHX_DISCONNECTED_CLASS;\n      this.loader.style.display = \"block\";\n      var middle = Math.floor(this.el.clientHeight / LOADER_ZOOM);\n      this.loader.style.top = \"-\".concat(middle, \"px\");\n    }\n  }, {\n    key: \"log\",\n    value: function log(kind, msgCallback) {\n      this.liveSocket.log(this, kind, msgCallback);\n    }\n  }, {\n    key: \"onJoin\",\n    value: function onJoin(_ref) {\n      var rendered = _ref.rendered;\n      this.log(\"join\", function () {\n        return [\"\", JSON.stringify(rendered)];\n      });\n      this.rendered = rendered;\n      this.hideLoader();\n      this.el.classList = PHX_CONNECTED_CLASS;\n      DOM.patch(this, this.el, this.id, Rendered.toString(this.rendered));\n      this.joinNewChildren();\n    }\n  }, {\n    key: \"joinNewChildren\",\n    value: function joinNewChildren() {\n      var _this10 = this;\n\n      var selector = \"\".concat(PHX_VIEW_SELECTOR, \"[\").concat(PHX_PARENT_ID, \"=\\\"\").concat(this.id, \"\\\"]\");\n      document.querySelectorAll(selector).forEach(function (childEl) {\n        var child = _this10.liveSocket.getViewById(childEl.id);\n\n        if (!child) {\n          _this10.liveSocket.joinView(childEl, _this10);\n        }\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(diff) {\n      if (isEmpty(diff)) {\n        return;\n      }\n\n      this.log(\"update\", function () {\n        return [\"\", JSON.stringify(diff)];\n      });\n      this.rendered = Rendered.mergeDiff(this.rendered, diff);\n      var html = Rendered.toString(this.rendered);\n      this.newChildrenAdded = false;\n      DOM.patch(this, this.el, this.id, html);\n\n      if (this.newChildrenAdded) {\n        this.joinNewChildren();\n      }\n    }\n  }, {\n    key: \"onNewChildAdded\",\n    value: function onNewChildAdded() {\n      this.newChildrenAdded = true;\n    }\n  }, {\n    key: \"bindChannel\",\n    value: function bindChannel() {\n      var _this11 = this;\n\n      this.channel.on(\"render\", function (diff) {\n        return _this11.update(diff);\n      });\n      this.channel.on(\"redirect\", function (_ref2) {\n        var to = _ref2.to,\n            flash = _ref2.flash;\n        return Browser.redirect(to, flash);\n      });\n      this.channel.on(\"session\", function (_ref3) {\n        var token = _ref3.token;\n        return _this11.el.setAttribute(PHX_SESSION, token);\n      });\n      this.channel.onError(function (reason) {\n        return _this11.onError(reason);\n      });\n      this.channel.onClose(function () {\n        return _this11.onGracefulClose();\n      });\n    }\n  }, {\n    key: \"onGracefulClose\",\n    value: function onGracefulClose() {\n      this.gracefullyClosed = true;\n      this.liveSocket.destroyViewById(this.id);\n    }\n  }, {\n    key: \"hasGracefullyClosed\",\n    value: function hasGracefullyClosed() {\n      return this.gracefullyClosed;\n    }\n  }, {\n    key: \"join\",\n    value: function join() {\n      var _this12 = this;\n\n      if (this.parent) {\n        this.parent.channel.onClose(function () {\n          return _this12.onGracefulClose();\n        });\n        this.parent.channel.onError(function () {\n          return _this12.liveSocket.destroyViewById(_this12.id);\n        });\n      }\n\n      this.channel.join().receive(\"ok\", function (data) {\n        return _this12.onJoin(data);\n      }).receive(\"error\", function (resp) {\n        return _this12.onJoinError(resp);\n      }).receive(\"timeout\", function () {\n        return _this12.onJoinError(\"timeout\");\n      });\n    }\n  }, {\n    key: \"onJoinError\",\n    value: function onJoinError(resp) {\n      this.displayError();\n      this.log(\"error\", function () {\n        return [\"unable to join\", resp];\n      });\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(reason) {\n      this.log(\"error\", function () {\n        return [\"view crashed\", reason];\n      });\n      this.liveSocket.onViewError(this);\n      document.activeElement.blur();\n\n      if (this.liveSocket.isUnloaded()) {\n        this.showLoader();\n      } else {\n        this.displayError();\n      }\n    }\n  }, {\n    key: \"displayError\",\n    value: function displayError() {\n      this.showLoader();\n      this.el.classList = \"\".concat(PHX_DISCONNECTED_CLASS, \" \").concat(PHX_ERROR_CLASS);\n    }\n  }, {\n    key: \"pushWithReply\",\n    value: function pushWithReply(event, payload) {\n      var _this13 = this;\n\n      var onReply = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n      this.channel.push(event, payload, PUSH_TIMEOUT).receive(\"ok\", function (diff) {\n        _this13.update(diff);\n\n        onReply();\n      });\n    }\n  }, {\n    key: \"pushEvent\",\n    value: function pushEvent(type, el, phxEvent) {\n      var val = el.getAttribute(this.binding(\"value\")) || el.value || \"\";\n      this.pushWithReply(\"event\", {\n        type: type,\n        event: phxEvent,\n        value: val\n      });\n    }\n  }, {\n    key: \"pushKey\",\n    value: function pushKey(keyElement, kind, event, phxEvent) {\n      var val = keyElement.value;\n\n      if (!val) {\n        val = event.key;\n\n        if (event.metaKey) {\n          val += \"meta-\";\n        }\n      }\n\n      this.pushWithReply(\"event\", {\n        type: kind,\n        event: phxEvent,\n        value: keyElement.value || event.key\n      });\n    }\n  }, {\n    key: \"pushInput\",\n    value: function pushInput(inputEl, phxEvent) {\n      this.pushWithReply(\"event\", {\n        type: \"form\",\n        event: phxEvent,\n        value: serializeForm(inputEl.form)\n      });\n    }\n  }, {\n    key: \"pushFormSubmit\",\n    value: function pushFormSubmit(formEl, phxEvent, onReply) {\n      this.pushWithReply(\"event\", {\n        type: \"form\",\n        event: phxEvent,\n        value: serializeForm(formEl)\n      }, onReply);\n    }\n  }, {\n    key: \"ownsElement\",\n    value: function ownsElement(element) {\n      return element.getAttribute(PHX_PARENT_ID) === this.id || maybe(element.closest(PHX_VIEW_SELECTOR), \"id\") === this.id;\n    }\n  }, {\n    key: \"submitForm\",\n    value: function submitForm(form, phxEvent) {\n      var _this14 = this;\n\n      var prefix = this.liveSocket.getBindingPrefix();\n      form.setAttribute(PHX_HAS_SUBMITTED, \"true\");\n      DOM.disableForm(form, prefix);\n      this.liveSocket.blurActiveElement(this);\n      this.pushFormSubmit(form, phxEvent, function () {\n        DOM.restoreDisabledForm(form, prefix);\n\n        _this14.liveSocket.restorePreviouslyActiveFocus();\n      });\n    }\n  }, {\n    key: \"binding\",\n    value: function binding(kind) {\n      return this.liveSocket.binding(kind);\n    }\n  }]);\n\n  return View;\n}();\n/* harmony default export */ __webpack_exports__[\"default\"] = (LiveSocket);\n\n//# sourceURL=webpack://phoenix_live_view/./js/phoenix_live_view.js?./node_modules/babel-loader/lib");

/***/ }),

/***/ "./node_modules/morphdom/dist/morphdom-esm.js":
/*!****************************************************!*\
  !*** ./node_modules/morphdom/dist/morphdom-esm.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrNamespaceURI = attr.namespaceURI;\n\n            if (attrNamespaceURI) {\n                attrName = attr.localName || attrName;\n\n                if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n                }\n            } else {\n                if (!toNode.hasAttribute(attrName)) {\n                    fromNode.removeAttribute(attrName);\n                }\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\n\nfunction toElement(str) {\n    if (!range && doc.createRange) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment;\n    if (range && range.createContextualFragment) {\n        fragment = range.createContextualFragment(str);\n    } else {\n        fragment = doc.createElement('body');\n        fragment.innerHTML = str;\n    }\n    return fragment.childNodes[0];\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    if (toEl.actualize &&\n        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */\n        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {\n        // If the target element is a virtual DOM node then we may need to normalize the tag name\n        // before comparing. Normal HTML elements that are in the \"http://www.w3.org/1999/xhtml\"\n        // are converted to upper case\n        return fromNodeName === toNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    /**\n     * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n     * attribute when reading over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var i = 0;\n            var curChild = toEl.firstChild;\n            while(curChild) {\n                var nodeName = curChild.nodeName;\n                if (nodeName && nodeName.toUpperCase() === 'OPTION') {\n                    if (curChild.hasAttribute('selected')) {\n                        break;\n                    }\n                    i++;\n                }\n                curChild = curChild.nextSibling;\n            }\n\n            fromEl.selectedIndex = i;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = {};\n        var keyedRemovalList;\n\n        function addKeyedRemoval(key) {\n            if (keyedRemovalList) {\n                keyedRemovalList.push(key);\n            } else {\n                keyedRemovalList = [key];\n            }\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    }\n                }\n\n                handleNodeAdded(curChild);\n                curChild = nextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n            var curFromNodeKey;\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it is will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (toNode.isSameNode && toNode.isSameNode(fromNode)) {\n                return;\n            }\n\n            if (!childrenOnly) {\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                morphAttrs(fromEl, toEl);\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n                var curToNodeChild = toEl.firstChild;\n                var curFromNodeChild = fromEl.firstChild;\n                var curToNodeKey;\n\n                var fromNextSibling;\n                var toNextSibling;\n                var matchingFromEl;\n\n                outer: while (curToNodeChild) {\n                    toNextSibling = curToNodeChild.nextSibling;\n                    curToNodeKey = getNodeKey(curToNodeChild);\n\n                    while (curFromNodeChild) {\n                        fromNextSibling = curFromNodeChild.nextSibling;\n\n                        if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                        var curFromNodeType = curFromNodeChild.nodeType;\n\n                        var isCompatible = undefined;\n\n                        if (curFromNodeType === curToNodeChild.nodeType) {\n                            if (curFromNodeType === ELEMENT_NODE) {\n                                // Both nodes being compared are Element nodes\n\n                                if (curToNodeKey) {\n                                    // The target node has a key so we want to match it up with the correct element\n                                    // in the original DOM tree\n                                    if (curToNodeKey !== curFromNodeKey) {\n                                        // The current element in the original DOM tree does not have a matching key so\n                                        // let's check our lookup to see if there is a matching element in the original\n                                        // DOM tree\n                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                            if (curFromNodeChild.nextSibling === matchingFromEl) {\n                                                // Special case for single element removals. To avoid removing the original\n                                                // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                                // we will instead discard the current node and wait until the next\n                                                // iteration to properly match up the keyed target element with its matching\n                                                // element in the original tree\n                                                isCompatible = false;\n                                            } else {\n                                                // We found a matching keyed element somewhere in the original DOM tree.\n                                                // Let's moving the original DOM node into the current position and morph\n                                                // it.\n\n                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                                // the `removeNode()` function for the node that is being discarded so that\n                                                // all lifecycle hooks are correctly invoked\n                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                                fromNextSibling = curFromNodeChild.nextSibling;\n\n                                                if (curFromNodeKey) {\n                                                    // Since the node is keyed it might be matched up later so we defer\n                                                    // the actual removal to later\n                                                    addKeyedRemoval(curFromNodeKey);\n                                                } else {\n                                                    // NOTE: we skip nested keyed nodes from being removed since there is\n                                                    //       still a chance they will be matched up later\n                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                                }\n\n                                                curFromNodeChild = matchingFromEl;\n                                            }\n                                        } else {\n                                            // The nodes are not compatible since the \"to\" node has a key and there\n                                            // is no matching keyed node in the source tree\n                                            isCompatible = false;\n                                        }\n                                    }\n                                } else if (curFromNodeKey) {\n                                    // The original has a key\n                                    isCompatible = false;\n                                }\n\n                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                                if (isCompatible) {\n                                    // We found compatible DOM elements so transform\n                                    // the current \"from\" node to match the current\n                                    // target DOM node.\n                                    morphEl(curFromNodeChild, curToNodeChild);\n                                }\n\n                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                                // Both nodes being compared are Text or Comment nodes\n                                isCompatible = true;\n                                // Simply update nodeValue on the original node to\n                                // change the text value\n                                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                                }\n\n                            }\n                        }\n\n                        if (isCompatible) {\n                            // Advance both the \"to\" child and the \"from\" child since we found a match\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        // No compatible match so remove the old node from the DOM and continue trying to find a\n                        // match in the original DOM. However, we only do this if the from node is not keyed\n                        // since it is possible that a keyed node might match up with a node somewhere else in the\n                        // target tree and we don't want to discard it just yet since it still might find a\n                        // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                        // that didn't find a home\n                        if (curFromNodeKey) {\n                            // Since the node is keyed it might be matched up later so we defer\n                            // the actual removal to later\n                            addKeyedRemoval(curFromNodeKey);\n                        } else {\n                            // NOTE: we skip nested keyed nodes from being removed since there is\n                            //       still a chance they will be matched up later\n                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                        }\n\n                        curFromNodeChild = fromNextSibling;\n                    }\n\n                    // If we got this far then we did not find a candidate match for\n                    // our \"to node\" and we exhausted all of the children \"from\"\n                    // nodes. Therefore, we will just append the current \"to\" node\n                    // to the end\n                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                        fromEl.appendChild(matchingFromEl);\n                        morphEl(matchingFromEl, curToNodeChild);\n                    } else {\n                        var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                        if (onBeforeNodeAddedResult !== false) {\n                            if (onBeforeNodeAddedResult) {\n                                curToNodeChild = onBeforeNodeAddedResult;\n                            }\n\n                            if (curToNodeChild.actualize) {\n                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                            }\n                            fromEl.appendChild(curToNodeChild);\n                            handleNodeAdded(curToNodeChild);\n                        }\n                    }\n\n                    curToNodeChild = toNextSibling;\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                // We have processed all of the \"to nodes\". If curFromNodeChild is\n                // non-null then we still have some from nodes left over that need\n                // to be removed\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n                    if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n                    curFromNodeChild = fromNextSibling;\n                }\n            }\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphEl(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (morphdom);\n\n\n//# sourceURL=webpack://phoenix_live_view/./node_modules/morphdom/dist/morphdom-esm.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack://phoenix_live_view/(webpack)/buildin/global.js?");

/***/ })

/******/ });
});